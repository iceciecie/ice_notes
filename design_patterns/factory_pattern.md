#### 简单工厂模式
- 用一个工厂方法来创建不同的对象, 适合需要创建的对象类型不多的情况

#### 工厂模式
- 当需要创建的对象类型越来越多时, 使用简单工厂方法可以解决此问题, 但是没新增一个对象类型, 就需要修改一次工厂类, 扩展不友好. 可以定义一个创建工厂的工厂, 为不同的对象类型创建专属于自己的工厂, 这样的话每新增一个对象类型, 只需要新增一个顶级工厂的实现类即可.

#### 抽象工厂模式
- 当创建的工厂类增多时, 可以通过将相似类型的对象放到同一个工厂中来创建, 可以减少工厂类的数量

#### 如何实现一个依赖注入容器(DI容器)
- DI容器的核心功能: 配置解析, 对象创建, 对象生命周期管理
- 配置解析时可以创建一个工厂类, 根据不同的配置类型获取不同的解析器; 对象创建时对于单例对象创建成功后需要缓存起来, 新的请求获取对象时直接获取缓存的实例即可; 对于原型模式则是在每次获取实例时创建
1. 读取配置信息
2. 根据配置信息创建bean

#### spring是如何解决循环依赖问题的
- spring存在三种循环的形式, 分别是构造器参数循环依赖, setter单例循环依赖, setter原型模式(prototype)循环依赖
1. 构造器参数循环依赖
    - 会报错, spring会将每一个正在创建的bean的标识符放到一个当前创建Bean池中, Bean标识符在创建过错中将一直保持, 如果在创建的Bean发现自己在池中则会抛出异常
2. 单例setter循环依赖
    - 会成功初始化, 因为单例的bean在spring中是先实例话再给属性赋值的, 对每一个成功实例化的bean, spring会将其保存到一个map中, 并且提供了获取这个实例的方法, 当其他对象去获取这个实例时是可以获取到的, 随意不会出现循环依赖
3. prototype循环依赖
    - 会报错, 因为spring不会缓存prototype的实例对象, 都是在获取此对象时才会初始化此对象, 所以会出现循环依赖, 导致报错
