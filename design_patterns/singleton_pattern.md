#### 什么是单例, 什么是单例设计模式?
- 一个类只允许创建一个实例, 这个类就叫做单例类, 这种设计模式就叫做单例设计模式

#### 为什么要使用单例模式?
1. 处理资源访问冲突
    - 在多线程情况下, 资源只有一份, 现假设操作资源的对象有多份且有多个线程操作不同的对象, 则资源对象对于资源的操作可能会造成紊乱, 比如写入文件操作，多个写操作之间可能相互覆盖, 如果操作资源的对象是单例的, 则可以通过给单例对象加锁的方式来控制并发操作造成的问题
2. 表示全局唯一类
    - 在系统中只应该保存一份的数据可以设计为单例模式, 比如系统配置信息, 唯一ID生产器等

#### 单例存在哪些问题?
- 单例对OOP特性的支持不友好 
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数, 可以通过两个办法解决
    1. 在调用getInstance()方法之前，先调用init(paramA, paramB...)方法传入需要的参数
    2. 讲参数放入到getIntance()方法中
#### 单例与静态类的区别?
    

#### 有什么替代的解决方案?
- 通过工厂模式, IOC容器来保证
- 编写代码时自己保证不会创建两个实例
- 使用静态方法来实现

#### 如何实现一个单例模式?
- 实现单例模式需要注意的要点
    1. 构造函数需要使用private修饰, 防止程序外部通过new关键字创建对象
    2. 考虑对象创建时的线程安全问题
    3. 考虑是否支持延迟加载
    4. 考虑getInstance()性能是否高(是否加锁)
- java实现单例的五种方式
    1. 饿汉式: 在类加载的时候, instance静态实例就已经创建完成, 调用getInstance()方法时, 直接返回已经创建好的静态实例
        - 优缺点: 不支持延迟加载, 系统启动时初始化实例, 若创建实例耗时长, 资源消耗大, 不利于系统启动
    2. 懒汉式: 在调用getInstance()方法时才初始化实例
        - 优缺点: 不占用系统启动时的资源; 支持延迟加载, 不浪费资源; 但是需要在getInstance()方法上加锁以保证线程安全, 性能不高
    3. 双重检测: 双重检测是在懒汉式的基础上进行升级, 通过细粒度锁和volatile关键字来满足并发要求, 支持延迟加载又支持高并发
    4. 静态内部类: 
    5. 枚举: java枚举类型本身保证线程安全和实例的唯一性, 用来实现单例最简单

#### 单例模式的唯一性
- 单例模式的唯一性需要考虑对象的作用范围, java中普通单例的作用范围是进程唯一的
- 实现线程唯一的单例
    - 创建一个map为每一个线程保存一个单例类的对象, java中可以使用ThreadLoacl来实现
- 集群唯一的单例
    - 创建集群唯一的单例需要借助第三方的存储来保存单例对象, 分为两步, 第一步是从存储中获取到单例对象并反序列化位实例在应用中使用, 并且要将存储系统中的数据加锁，保证其他线程不会获取到该对象; 第二步当单例实例使用结束以后, 先将最新的单例对象序列化存储到存储系统中, 并将当前对象的引用置空, 再释放存储系统中的锁

#### 如何实现多例模式
- 创建指定数量的实例, 通过一个map保存指定数量的实例, 为每一个实例分配一个key并标记其使用状态, 当需要时通过key来获取



























