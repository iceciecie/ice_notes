#### 并发问题的源头：可见性、原子性、有序性问题
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性
- 原子性：我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性

###### 可见性问题
- 导致原因：CUP在执行程序时，会将主内存中的变量复制一份到自己的CPU缓存中，在操作变量时操作的是CPU缓存中的数据。在多核时代，当不同线程都需要操作一个共享变量时，若多个线程是在不同的CPU在执行的，则他们操作的是各自的CPU缓存，而各个CPU缓存又是相互不可见的，这就会导致数据可见性问题

###### 原子性问题
- 导致原因：操作系统进行线程切换带来原子性问题

###### 有序性问题
- 导致原因：编译优化带来有序性问题，比如双重加锁检查的单例模式

###### java如何解决可见性问题
- 使用valatile关键字，被修饰的共享变量在任何一个线程中的修改对其线程而言都是可见的

###### java如何解决有序性问题
- 虚拟机实现时会保证六项happen-before原子，这保证了语义级别的有序性
  1. 程序的顺序性原则。程序按顺序执行，前面程序比后面的程序更早执行
  2. volatile变量规则。按执行时间顺序，对一个变量的写操作早于对一个变量的读操作
  3. 传递性。如果A Happen-Before B，B Happen-Before C，则A Happen-Before C
  4. 锁的规则。对一个锁的解锁 Happen-Before 后续对这个锁的加锁
  5. 线程start()规则。主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作
  6. 线程join()规则。主线程A等待子线程B完成，子线程B操作完成后，主线程A能够看到子线程B对共享变量的操作
- valatile关键字会禁止指令重排序，在对被修饰的变量做操作时，其CPU指令的有序性是得到保证的

###### java如何解决原子性问题
- 通过互斥锁的方式保证原子性
