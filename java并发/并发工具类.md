#### Lock和Condition

###### Lock解决了synchronized的哪些不足？
- synchronized不能通过“破坏不可抢占条件”来破除死锁，而lock提供了响应式中断、超时机制、非阻塞的获取锁三种方式来实现，当线程未能获取锁时，可以放弃其原来持有的锁。这样“不可抢占条件”就被破坏了
- 破坏不可抢占条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
- Lock提供的三种“破坏不可抢占条件”的方法
  1. 支持终端的API：void lockInterruptibly()
  2. 支持超时的API：boolean tryLock(long time, TimeUnit unit) throws InterruptedException
  3. 支持非阻塞获取锁的API：boolean tryLock()

###### Lock如何保证可见性
- ReentrantLock内部持有一个volatile的成员变量state，获取锁时会读写state的值，释放锁时也会读取state的值，在单个线程内由于顺序性的happen-before原则，对于任何共享的变量操作都是happen-before与解锁时对state的读写操作的，下一个线程在加锁时也需要读写state的值，由于volatile变量happen-before原则，新的线程中任何操作都在state的读写之后，再根据传递性原则即可保证可见性

###### 可重入锁
- 指线程可以重复获取同一把锁，其目的在于防止死锁。
- 场景：funA()和funB()是同一个类的同步方法，在funA()内funB()调用了funB()，由于是同一个对象的两个方法，调用funA()时不会出现死锁，但是又是在同一把锁内再此获取此锁，所以叫可重入锁
- 实现原理：jvm为每一个锁维护一个计数器和线程ID，计数器初始值位0，当线程T获取到此锁时，其他的线程就不能获取到这把锁，且讲计数器的值加1，当重入时，计数器的值再加1；当释放一层锁时，计数器的值减1，一直到计数器的值位0时，认为此锁已经无占用，可以被其他线程获取了

###### 公平锁和非公平锁
- 在new ReentrantLock的时候可以通过传递一个boolean的方式来创建公平锁或者非公平锁，不传boolean值时默认位非公平锁
- 公平锁：线程未获取到锁时，会进入入口等待队列，当有线程释放锁后，会依次从队列中获取线程来执行。即谁等待的时间长，就唤醒谁
- 非公平锁：线程锁释放后，如果来了一个线程获取锁，它不必去排队获取锁，也就是不用进入入口等待队列，获取不到时才进入入口等待队列

###### 用锁的最佳实践
1. 永远只在更新对象的成员变量时加锁
2. 永远只在访问可变的成员变量时加锁
3. 永远不在调用其他对象的方法时加锁
4. 减少锁的持续时间、减少锁的粒度

###### Dubbo中异步转同步的实现
1. 发送请求后，直接调用get()方法获取返回信息
2. 由于返回信息为null，Condition.await()。当接受到回调数据后，返回信息不为null，在接受返回参数的doReceived()方法中，调用Condition.signalAll方法唤醒等待线程

###### signal()和signalAll()的区别
- signal()方法会唤醒条件等待队列中的一个线程，signalAll()方法会唤醒同一条件等待队列的所有线程，其好处在于不会出现有的线程一直阻塞直到超时的情况

###### 信号量
- 信号量的组成，一个计数器、一个等待队列、三个方法
1. init()方法：设置计数器的初始值。在java中为Semaphore对象初始化时可以直接指定计数器的初始值
2. down()方法：计数器的值减1；如果此时计数器的值小于0，则当前线程将被阻塞，否则当前线程可以继续执行。在java中对应与Semaphore.acquire()方法
3. up()方法：计数器的值加1；如果此时计数器的值小于或者等于0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。在java中对应Semaphore.release()方法
- Semaphore可以实现的独特功能就是同时允许多个线程进入临界区，但是Semaphore不能同时唤醒多个线程去争抢锁，只能唤醒一个阻塞中的线程，而且线程被唤醒后是直接执行的而不去检查此时临界条件是否已经不满足了。
- 信号量支持多个线程进入临界区，在临界区内多个线程执行时，可能有线程安全问题

###### ReadWriteLock
- java提供的读写锁，其支持如下规则
  1. 允许多个线程同时读共享变量
  2. 只允许一个线程写共享变量
  3. 如果一个线程正在写共享变量，读共享变量的线程会阻塞
- 读写锁和互斥锁的区别在于读写锁允许多个线程同时读取共享变量
- 锁的升级和降级
  1. 锁的升级，先获取读锁，再升级位写锁，是锁的升级，ReentrantReadWriteLock不支持锁的升级
  2. 锁的降级，先获取写锁，再降级位读锁，是锁的降级，ReentrantReadWriteLock支持锁的降级
- ReentrantReadWriteLock的写锁支持条件变量，但是读锁不支持条件变量；读锁调用new Condition()会抛出异常

###### StampedLock
- StampedLock支持三种锁模式，写锁、悲观读锁、乐观读。其中写锁和悲观读锁与ReadWitetLock的写锁、读锁类似
- 乐观读：乐观读不是锁，在读的时候是不加锁的，其首先获取一个stamp，再读取数据，再验证stamp是否发生变化，若在乐观读期间有过写操作，则stamp的值会发生变化，需要进行处理。常见的方式是直接升级位悲观读锁。
- 使用要点
  1. 不支持重入
  2. 写锁和悲观读锁都不支持条件变量
  3. StampedLock一定不能使用中断操作，如果一定要支持中断操作，需要使用可终端的悲观读锁readLockInterruptibly()和可中断的悲观写锁writeLockInterruptibly()

###### CountDownLatch


###### CyclicBarrier
