### 数据库锁
- 锁的分类：根据加锁的范围，可以分为全局锁、表级锁、行锁

### 全局锁
- 什么是全局锁？
  - 全局锁就是对整个数据库实例加锁，加锁后整个数据库处于只读状态。此时insert、update、delete、ddl操作、更新事务的提交操作都会被阻塞
- 全局锁的使用场景？
  - 典型使用场景是给数据库做全库的逻辑备份。也就是在某个固定时间点将整个库的所有表数据都select出来保存
- 全局锁会使全库只读，这样做有什么危险？
  1. 如果是在主库上备份，此时不仅进行写操作，业务基本停摆
  2. 如果是在读库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟
- 全局锁的作用是使全库只读，除了使用FTWRL命令外还有什么其他办法？
  - 全局锁是通过保证固定时间点所有表读取的数据不会发生变化来实现逻辑备份的，在可重复度隔离情况下的事务也满足这一要求。可重复读是可以满足逻辑备份的要求的，但是要求所有的表都是支持事务的，如果用了不支持事务的引擎，则只能使用FTWRL
- 全局锁使得全库只读，为什么不适用set global readonly=true来实现呢？
  1. 修改global变量影响大，因为global变量可能用于其他逻辑，比如有的系统会用readonly值来判断是主库还是从库
  2. FTWRL和readonly在异常处理机制上有差异。FRWRL在客户短异常断开时，会自动释放锁；但是readonly不会释放锁，而是一直保持readonly状态，这样会导致整个库长时间处于不可写的状态，比较危险

### 表级锁
- mysql中表级锁有两种，一是表锁，而是元数据锁
##### 表锁
- 表锁分为读锁和写锁。读锁和读锁不互斥，读锁和写锁互斥、写锁和写锁，读锁均互斥。
- 使用lock tables ... read/write来加锁/解锁。在客户端断开时，锁也会主动释放
- lock tables 除了会限制别的线程读写外，也会限定本线程接下来的操作对象
- 在没有更细粒度的锁的支持下，表锁是最常用的并发处理方式。如果有类似行锁这样的机制，基本不会使用表锁了
##### MDL锁（metadata lock）
- MDL锁不需要显式的使用，mysql会自动添加。当对一个表进行增删改查时会添加MDL读锁；当对表做结构变更时，加MDL写锁。
  - 读锁和读锁不互斥，因此可以多个线程同时对一张表增删改查
  - 读锁和读锁、读锁和写锁均互斥，用来保证变更表结构时的安全性。因此不同的DDL是互斥的
- 为什么给一个小表加字段，整个库挂了？
  1. MDL锁在语句开始执行时申请，但是语句结束后并不会马上释放，二是等到整个事务提交后再释放
  2. 数据库内等待锁的线程是通过队列的方式排队执行的
  3. 由于存在未提交的长事务，在执行添加字段操作时拿不到MDL读锁，所以DDL操作会堵塞。此时后续的增删改查操作又会源源不断的进到数据库中，导致整个数据库的线程会爆满
- 如何安全的给小表加字段？
  1. 在给小表加字段过程中，如果发现由于长事务导致一直拿不到MDL写锁，可以将长事务直接kill掉。但是若数据库操作比较频繁，这中方法也会麻烦
  2. 在执行添加字段操作时，在alert语句里设置等待时间，如果等待时间内能拿到MDL锁，则执行操作，如果拿不到则先放弃，不要阻塞后面的语句，等后续在重新尝试这个命令

### InnoDB行锁
- 两阶段锁协议：事务开启后，行锁在需要的时候才加上的，但并不是不需要了就立即释放，二是直到事务提交才会释放锁
- 在事务需要多个行锁时，尽量把最可能造成锁冲突、最可能影响并发度的锁往后方，以减少等待锁、占有锁的时间
- 两个事务相互依赖对方的行锁，则会造成死锁，解决死锁的策略有两种，正常情况下多使用第二种方法
  1. 一直等待，直到超时
  2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行
- 死锁检测是一个消耗CPU的操作，当同时存在大量的死锁检测时，数据的CPU压力会很大，解决的办法有两个
  1. 临时放弃死锁检查。但是这样需要承担业务超时的风险
  2. 控制并发度，使得一段时间内只有一定数量的死锁检测。可以通过中间件实现，也可以修改源码。从设计角度看可以将一行改成多行来减少锁冲突，比如金额本来是一行，改成10行，这样冲突的记录就是原来的1/10，但是要注意处理边界问题

### 事务隔离
- 隔离级别：隔离级别越高，事务执行的效率也就越低
  1. 读未提交：一个事务还没提交，它做的变更就能被其他事务读到
  2. 读提交：一个事务只有提交后，它做的变更才能被其他事务读到
  3. 可重复读：一个事务执行过程中看到的数据，总是和这个事务启动时看到的数据是一致的，且该事务未提交前做的变更对其他事务也是不可见的
  4. 串行化：对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行
- 隔离通过视图的方式实现，在不同的隔离级别下，创建的视图也是不一样的
  1. 读未提交：直接返回的是记录上的最新值，此时不创建视图
  2. 读提交：在每一个sql语句开始执行时创建
  3. 可重复度：在事务启动时创建，整个事务存在期都用这个视图
  4. 串行化则是直接通过加锁的方式来避免并行访问
- 事务隔离的实现：mysql会在每一条记录更新时保留对于的回滚操作，记录上的最新值都可以通过回滚操作恢复到前一个状态的值。事务启动时，会根据当前最新的记录值，使用事务启动时间点到最新记录值时间点之间的回滚操作将数据回滚到事务启动时的状态。
  - 注意事项：对于一条回滚日志来说，当系统中没有比这个回滚日志更早的视图时，就会删除此回滚日志。不要使用长事务，因为长事务会使得数据库中会存在时间很老的视图，与之对应的回滚日志就必须保留，这样会占用大量的存储空间
- 事务的启动方式
  1. begin/start transation：启动事务，但是事务真正开始启动是执行此命令后，第一个执行操作InnoDB表的语句的时候
  2. set autocommit=1：操作表的语句本身就是一个事务，再语句执行结束后会自动提交
  3. start transation with consistent snapshot：马上启动一个事务
  4. commit work and chain：提交事务并自动启动下一个事务
- mysql中的两个视图
  1. view。是一个用查询语句定义出来的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view...，view的查询方法与表一致
  2. InnoDB在实现MVCC时用到的一致性视图，即consistent read view，用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复读)隔离级别的实现，其没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”
