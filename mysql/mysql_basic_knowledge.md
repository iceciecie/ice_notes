### 数据库锁
- 锁的分类：根据加锁的范围，可以分为全局锁、表级锁、行锁

### 全局锁
- 什么是全局锁？
  - 全局锁就是对整个数据库实例加锁，加锁后整个数据库处于只读状态。此时insert、update、delete、ddl操作、更新事务的提交操作都会被阻塞
- 全局锁的使用场景？
  - 典型使用场景是给数据库做全库的逻辑备份。也就是在某个固定时间点将整个库的所有表数据都select出来保存
- 全局锁会使全库只读，这样做有什么危险？
  1. 如果是在主库上备份，此时不仅进行写操作，业务基本停摆
  2. 如果是在读库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟
- 全局锁的作用是使全库只读，除了使用FTWRL命令外还有什么其他办法？
  - 全局锁是通过保证固定时间点所有表读取的数据不会发生变化来实现逻辑备份的，在可重复度隔离情况下的事务也满足这一要求。可重复读是可以满足逻辑备份的要求的，但是要求所有的表都是支持事务的，如果用了不支持事务的引擎，则只能使用FTWRL
- 全局锁使得全库只读，为什么不适用set global readonly=true来实现呢？
  1. 修改global变量影响大，因为global变量可能用于其他逻辑，比如有的系统会用readonly值来判断是主库还是从库
  2. FTWRL和readonly在异常处理机制上有差异。FRWRL在客户短异常断开时，会自动释放锁；但是readonly不会释放锁，而是一直保持readonly状态，这样会导致整个库长时间处于不可写的状态，比较危险

### 表级锁
- mysql中表级锁有两种，一是表锁，而是元数据锁
##### 表锁
- 表锁分为读锁和写锁。读锁和读锁不互斥，读锁和写锁互斥、写锁和写锁，读锁均互斥。
- 使用lock tables ... read/write来加锁/解锁。在客户端断开时，锁也会主动释放
- lock tables 除了会限制别的线程读写外，也会限定本线程接下来的操作对象
- 在没有更细粒度的锁的支持下，表锁是最常用的并发处理方式。如果有类似行锁这样的机制，基本不会使用表锁了
##### MDL锁（metadata lock）
- MDL锁不需要显式的使用，mysql会自动添加。当对一个表进行增删改查时会添加MDL读锁；当对表做结构变更时，加MDL写锁。
  - 读锁和读锁不互斥，因此可以多个线程同时对一张表增删改查
  - 读锁和读锁、读锁和写锁均互斥，用来保证变更表结构时的安全性。因此不同的DDL是互斥的
- 为什么给一个小表加字段，整个库挂了？
  1. MDL锁在语句开始执行时申请，但是语句结束后并不会马上释放，二是等到整个事务提交后再释放
  2. 数据库内等待锁的线程是通过队列的方式排队执行的
  3. 由于存在未提交的长事务，在执行添加字段操作时拿不到MDL读锁，所以DDL操作会堵塞。此时后续的增删改查操作又会源源不断的进到数据库中，导致整个数据库的线程会爆满
- 如何安全的给小表加字段？
  1. 在给小表加字段过程中，如果发现由于长事务导致一直拿不到MDL写锁，可以将长事务直接kill掉。但是若数据库操作比较频繁，这中方法也会麻烦
  2. 在执行添加字段操作时，在alert语句里设置等待时间，如果等待时间内能拿到MDL锁，则执行操作，如果拿不到则先放弃，不要阻塞后面的语句，等后续在重新尝试这个命令

### InnoDB行锁
- 两阶段锁协议：事务开启后，行锁在需要的时候才加上的，但并不是不需要了就立即释放，二是直到事务提交才会释放锁
- 在事务需要多个行锁时，尽量把最可能造成锁冲突、最可能影响并发度的锁往后方，以减少等待锁、占有锁的时间
- 两个事务相互依赖对方的行锁，则会造成死锁，解决死锁的策略有两种，正常情况下多使用第二种方法
  1. 一直等待，直到超时
  2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行
- 死锁检测是一个消耗CPU的操作，当同时存在大量的死锁检测时，数据的CPU压力会很大，解决的办法有两个
  1. 临时放弃死锁检查。但是这样需要承担业务超时的风险
  2. 控制并发度，使得一段时间内只有一定数量的死锁检测。可以通过中间件实现，也可以修改源码。从设计角度看可以将一行改成多行来减少锁冲突，比如金额本来是一行，改成10行，这样冲突的记录就是原来的1/10，但是要注意处理边界问题

### 事务隔离
- 隔离级别：隔离级别越高，事务执行的效率也就越低
  1. 读未提交：一个事务还没提交，它做的变更就能被其他事务读到
  2. 读提交：一个事务只有提交后，它做的变更才能被其他事务读到
  3. 可重复读：一个事务执行过程中看到的数据，总是和这个事务启动时看到的数据是一致的，且该事务未提交前做的变更对其他事务也是不可见的
  4. 串行化：对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行
- 隔离通过视图的方式实现，在不同的隔离级别下，创建的视图也是不一样的
  1. 读未提交：直接返回的是记录上的最新值，此时不创建视图
  2. 读提交：在每一个sql语句开始执行时创建
  3. 可重复度：在事务启动时创建，整个事务存在期都用这个视图
  4. 串行化则是直接通过加锁的方式来避免并行访问
- 事务隔离的实现：mysql会在每一条记录更新时保留对于的回滚操作，记录上的最新值都可以通过回滚操作恢复到前一个状态的值。事务启动时，会根据当前最新的记录值，使用事务启动时间点到最新记录值时间点之间的回滚操作将数据回滚到事务启动时的状态。
  - 注意事项：对于一条回滚日志来说，当系统中没有比这个回滚日志更早的视图时，就会删除此回滚日志。不要使用长事务，因为长事务会使得数据库中会存在时间很老的视图，与之对应的回滚日志就必须保留，这样会占用大量的存储空间
- 事务的启动方式
  1. begin/start transation：启动事务，但是事务真正开始启动是执行此命令后，第一个执行操作InnoDB表的语句的时候
  2. set autocommit=1：操作表的语句本身就是一个事务，再语句执行结束后会自动提交
  3. start transation with consistent snapshot：马上启动一个事务并创建一个持续整个事务的一致性快照，这个只在可重复度的隔离登记下有作用，其他的隔离登记下等同于begin/start transation
  4. commit work and chain：提交事务并自动启动下一个事务
- mysql中的两个视图
  1. view。是一个用查询语句定义出来的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view...，view的查询方法与表一致
  2. InnoDB在实现MVCC时用到的一致性视图，即consistent read view，用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复读)隔离级别的实现，其没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”
- mysql是如何实现MVCC一致性视图的 **<font color="red">需要进一步理解！！！</font>**
  1. InnoDB中的每一个事务都有一个事务ID，叫做transaction id，它是在事务开始的时候向InnoDB事务系统申请的，是按撒申请顺序严格递增的，当每次事务更新数据时，都会生成一个新的数据斑斑，并且把transation id赋值给这个数据版本的事务ID，同时旧的事务版本也会保留。当处于可重复度隔离级别下，其作用在于对不同时间点启动的事务可以根据事务版本来确定数据的可见性。
  2. 事务启动的瞬间，InnoDB会为每个事务构造一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。
  3. MYSQL更新数据时都是先度后写，而且只能读当前的值，称为“当前读”。同时加了锁的select语句，也是当前读
- 一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况
  1. 版本未提交，不可见
  2. 版本已提交，但是是在视图创建后提交的，不可见
  3. 版本已提交，而且是在事务创建前提交的，可见
- 读提交和可重复读的区别是
  1. 可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图。也就是说对于一个数据只需要保存一次事务版本的数组信息
  2. 在读提交隔离级别下，每一个语句都会重新算出一个新的视图。也就是说，每一个语句都需要保存一次事务版本的数组信息

#### 索引
- 索引的出现是为了提高数据查询的效率，类似书的目录
- 索引的常见数据类型
  1. 哈希表：是一种以k-v形式存储数据的结构，先将k值hash后确定一个具体的位置，再将value值放入此位置。当hash冲突时，使用链表的方式来往后延展。由于hash后位置不是连续的，且链表也不是有序链表，所以hash表的方式只适合等值查询的场景
  2. 有序数组：有序数组是通过数组的方式来保存数据，且数据是有序的。由于有序数组是连续的，所以有序数组的等值查询和区间查询都是很快的，但是当数据需要频繁更新时，效率就比较低，因为需要移动大量的数据来保持有序性。有序数组值适合静态存储引擎
  3. 搜索树：搜索树的查询和更新操作都是比较好的选择，但是由于数据库的数据量很大，如果是而叉搜索树的话，树的层次（树高）会比较大，对于固定数量的数据来说，树高越大，当需要读取数据时，磁盘I/O的次数就越多，所以实际中多使用N叉搜索树
- 数据库的数据类型对与数据库来说非常重要，理解数据库的各种数据类型有利于更好的使用数据库
- InnoDB的索引模型
  1. 表的数据是根据主键顺序以索引的形式存放的，这种存储的方式称为索引组织表。索引使用的是B+树索引模型
  2. 主键索引的叶子节点保存的是主键对应的整行记录，非主键索引保存的是主键的内容。主键索引称为聚族索引，非主键索引称为二级索引
- 为什么查询时要尽量基于主键查询？
  - 基于主键查询只需要扫描主键对于的B+树，基于非主键索引，需要先扫描非主键索引的B+树，拿到主键值后再去扫描主键索引的B+树
- 索引维护
  1. 若新增的数据是有序的，则只需要将新的数据在B+树后新增即可，若是无序的，则需要挪动数据的位置
  2. 如果挪动数据位置的页是满的，则需要新申请一个数据页并做对应的数据迁移，这称为页分裂。页分裂不仅会影响性能，还会造成数据页的利用率下降
  3. 由于非主键索引都需要保存主键信息，所以如果主键占有空间小的话，那整个表的索引占有空间都会小
- 使用自增主键的好处
  - 每次新增的主键都是递增的，在B+树中做的都是追加操作，不会触发数据移动，也不会触发叶子节点的分裂。递增主键通常为数字型，占用空间小，非主键索引占有的空间也会小，可以节省磁盘空间
- 回表：主键索引保存了全部的数据信息，非主键索引保存的是索引列加上主键列值。在数据查询时，如果存在回到主键索引树上搜索的情况，就称为回表
- 覆盖索引：非主键索引保存的是索引列信息和主键信息，查询时如果查询的列都是非主键索引列，则不需要回表去获取数据，这总情况称为覆盖索引
- 最左前缀原则：创建索引时，根据列的最左N位创建索引，也可以起到索引的效果。
- 创建联合主键时字段的顺序安排：
  1. 联合索引只对索引首列的查询起到索引作用
  2. 联合索引对非索引首列有覆盖索引的作用
  3. 联合索引对索引首列的搜索其加速作用，其保存了索引全列的数据，所以在查询非索引首列时不需要回表，提高了查询效率
  4. 由于联合索引对非索引首列不起搜索加速作用，非索引首列也有频繁的查询操作，则需要对其单独创建索引。
  5. 当即需要创建联合索引，又需要创建单独索引时，处于索引存储空间最小化的考虑，可以为列较小的字段单独创建索引并将列较大的放在联合索引的最左边
- 索引下推：在索引遍历过程中，先对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
