## 一条SQL查询语句是如何执行的
#### 连接器
- 负责连接数据库Server层和客户端，维护数据库连接连接成功后会去到权限表中读取该用户的权限，该用户此次连接的权限就此不再发生变化，直到断开连接重新连接后，权限才会重置
- 客户端和数据库间的连接最长闲置时间由wait_timeout控制，默认为8小时，超过这个时间，连机器就会将这个连接断开
- mysql在执行过程中使用的临时内存是管理在连接对象中的，所以使用长连接时，会出现内存占用升高的情况，如果不及时处理，可能出现OOM，解决办法有两个
  1. 定时断开长连接
  2. 如果版本大于等于5.7的话，可以通过执行mysql_reset_connection来重新初始化连接，这个过程不需要重新连接，也不需要要重新做权限认证，但是可以将连接恢复到刚创建时的状态

#### 查询缓存
- mysql中如果设置了缓存的话，会在内存以k-v的形式缓存部分数据，key是查询语句，value就是查询的结果。mysql查询时，如果设置了查询缓存或者使用sql指定了查询缓存的话，就会先去缓存中查询信息，缓存中有，则直接返回缓存结果，缓存中没有则会去查询数据库，将查询到的结果返回给客户端同时将数据缓存在内存中，下次以相同的查询语句查询时就直接命中缓存中的数据就可以了
- 查询缓存只适合读多写少的数据库，否决不仅缓存的命中率低，而且对数据库的性能有很大影响
- 在mysql8.0版本缓存的功能直接删除掉了。

#### 分析器 - 决定要做什么
- 分析器用来识别和检查输入的sql语句，分为词法分析和语法分析两种
  1. 词法分析：用来分析输入的sql由哪些字符组成，每个字符代表什么含义，哪些是mysql关键字，哪些是表名，哪些是列名等
  2. 语法分析：分析输入的sql是否符合mysql的语法规范

#### 优化器 - 决定要怎么做
- 优化器会决定输入的sql使用哪个索引，决定各个表的连接顺序

#### 执行器
- 首先校验权限，检查用户是否有查询目标表的权限。调用引擎的接口，查询结果并返回

#### sql更新语句和查询语句执行的流程大致是一样的，但有三个不同点
1. 更新语句执行成功后，会将与此更新语句有管的查询缓存失效掉
2. 更新语句会在Server记录binlog(归档日志)
3. 如果使用的是InnoDB引擎的话，会记录redo log(重做日志)

#### binlog和redolog
- binlog：binlog是Server层特有的，使用任何引擎都会记录binlog，它记录了所有执行了的sql语句
使用biglog的目的是为了能够还原数据
- redo log：redo log是InnoDB引擎特有的，当执行更新语句时，会先记录redo log并更新内存，记录完成后，事务就可以提交了。InnoDB会在合适的时候将数据一起flush到磁盘中。好处是可以减少对磁盘的I/O操作
- redo-log在mysql内部是固定大小的，其数据结果是一个环状，固定大小为4G，有两个指针，一个记录日志插入的位置，一个记录空闲的最远位置，当插入的位置追上空闲的最远位置时，就必须停下来先将部分数据flush进磁盘，腾出redo-log的空间才可以继续写日志
- 两阶段提交：为了保证redo-log和binlog逻辑上的一致性，redo-log使用两阶段提交
  1. 记录redo-log，此时redo-log处于prepare状态
  2. 记录binlog
  3. 将redo-log改成提交状态
  4. 如何保证一致性?
    1. 当执行到2时发生异常，mysql重启后，由于只有prepare状态的redo-log，没有binlog，系统回滚，前后数据保持一致
    2. 当执行到3时发生异常，mysql重启后，由于同时存在prepare状态的redo-log和binlog，系统自动提交，前后数据保持一致
