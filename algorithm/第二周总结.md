#### HashMap的总结
- HashMap的数据结构特点？
  1. 以K-V键值对的方式保存数据
  2. 定义了Node<K,V>静态内部类保存K-V数据
  3. 定义了一个Node<K,V>类型的数组来保存Node对象。新增，获取，删除时，先将Node对象的K值经过Hash之后算出在数组中的index，再将Node对象放置在数组的index位置上。
  4. 对于hash冲突时，会在index的位置下拉一个链表出来，当链表的长度大于一定值时，将其转化为红黑树
- HashMap的主要方法及实现？
  - new HashMap()
    1. 无参，默认指定负载因子0.75
    2. 带初始化size，检查size合法性，设置size，设置默认负载因子为0.75
    3. 带size和负载因子，检查size和负载因子合法性，并设置对应属性值
  - put方法
    1. 判断存储数据的数组是否为空，为空则要重新生成一个
    2. 先通过hash值和数组的size-1进行&运算，计算出下标index，如果此下标对于的位置为空，则将Node放置在此位置
    3. hash冲突时，进行三种判断
      1. 判断key的hash值相同且equals，则将value值替换，覆盖掉原来的老值
      2. 如果hash冲突时，发现index上的节点是一个树节点，则将值添加到树中
      3. 如果不是树节点则添加到链表的next中
  - get方法
    1. 判断保存Node节点的数组是否为空及hash后的index位置是否有值，如果为空直接返回null
    2. 先判断数据index位置的节点是否hash值相同且是否equals key，相同则直接否决，否则往下探到下一个元素
    3. 如果下一个元素是tree，则遍历树，否决遍历链表，根据hash值相同且equals key来获取对于的数据
  - remove方法
    1. 判断保存Node节点的数组是否为空及hash后的index位置是否有值，如果为空直接返回null
    2. 先判断index位置的hash值是否和remove key的hash相同，再看是否equals key，匹配的话先保存此node
    3. 如果2中未命中，则往下探，先判断树，再判断链表，获取key值对应的node
    4. 如果需要删除的node节点不为空，则根据其类型为树or链表进行删除
- HashMap的线程安全问题
  - HashMap在put的时候，如果put之后数量大于定值，就会发生resize，紧接着就是数据搬移，此过程是没有加锁的
  不是线程安全的
- 如何实现线程安全的HashMap?
  1. 可以使用hashTable
  2. 使用Collections.synchronizedMap(new HashMap())包装Map，使其线程安全
  3. 使用java.util.concurrent.ConcurrentHashMap

#### 遍历N叉树的总结
- 使用递归遍历树时如果要将树的元素获取出来，就需要有容器可以收集这些元素，有两种方式，第一种是使用全局变量，因为这样的话可以在类中的任何位置使用；第二中方式就是将容器传入到方法中，在方法中往容器中添加元素。递归时关键在于判断什么情况下再次调用函数，即递归终结条件

#### 刷题总结
- 字母异位词分解中，关键在于判断两个字符串是否为异位词。使用hash表和使用其他的数据结构都一样，都是为了存储数据，hash表的好处就是查找的时间复杂度是O(1)的，也可以使用链表，头节点为排序过的字符串也行，也可以找到对应的位置，只是查找时间复杂度为O(n)。官方题解中统计字符出现次数的方法有缺陷，如果出现不是26个字母的数据，就会有问题，扩展的方式可以是遍历字符串数据中的所有字符，给每一个字符都提供一个唯一的编码
- 在做树的题目时，一定要注意考虑是否包含当前节点，而且在往下一层下探时，要注意下一层节点的选择，假设当前层有指针指向动态的节点，则要处理好这些指针指向下一层的节点。
- 刷题时，有些想法和leeCode的解法思维类似，但是代码写的差很多，要多看，看高手是怎么写出简洁的代码的。
