[TOC]
# 研发效能

## 相关概念

### 研发效能的定义, 模型 - 定义: 团队能够持续地为客户产生有效价值的效率
- 包括有效性, 效率, 可持续性三个方面, 三者必须兼顾
    1. 有效性, 产品对公司和客户一定是有价值的, 否决做出来也是白做, 浪费资源
    2. 效率, 指的是速度, 正确性, 在一定的时间内产出越多, 效率越高
    3. 可持续性, 高效的产出要有持续性, 否决短期的高产出可能会影响到长期的产出, 比如短期突击加班带来的身体问题导致后续工作效率低下

### 为什么要关注研发效能
- 业务发展迅速, 工作量不断加大, 传统的堆人, 加班堆工时的方法和会不断的扩大人力成本, 消耗开发人员的精力和积极性, 而且由于人员越来越多, 相互之间沟通的成本会越来越大, 出现问题的几率也会大很多
- 研发效能的提高能让开发着更效率的产生价值, 能容易精进自己的技术, 团队更有经历和好的开发氛围, 从而支撑持续的高效开发

### 如何度量研发效能
- 软件开发和传统制造业类似, 大致流程都是流水线作业.软件开发可以分为产品, 开发, 测试, 运维等多个不同的节点, 但与传统制造业不同, 软件开发有其本身的灵活性, 总结来说,研发效能的本质就是一条超级灵活的流水线
- 和传统制造业相比, 软件开发具有超强的灵活性, 主要体现在四个方面
    1. 最终产品目标的灵活性, 其产品的最终形态是在不断迭代中确定的, 不是一成不变的
    2. 节点之间的灵活性, 多个节点可以相互融合
    3. 每个节点有自己的灵活性, 比如测试节点就有各自不同的测试方法
    4. 每个节点上开发人员的灵活性
    - 根据不同的灵活性, 需要提高相应的效能, 针对1, 2需要提高流程的效能; 针对3不同的节点采用不同的工程方法, 提高效能; 针对4提高个人的效能
- 彼得.得鲁克: 一个事物,你如果无法度量它, 就无法管理它.(If you can't measure it, you can't manage it)
- 度量研发效能的目的
    1. 跟踪团队表现, 提高团队效率
    2. 提高项目计划的精准度
    3. 了解流程是否高效, 寻找需要改进的关键领域
- 研发效能难以度量的原因
    1. 软件开发工作是一项创造性很强的知识性工作, 非常复杂且伴随有大量不确定因素
    2. 很多公司存在竖井效应, 常常将注意力放在某一两个竖井中, 进行局部优化. 但是局部优化并不代表全局优化, 甚至会让全局恶化
    3. 度量指标一般是用来度量软件生产过程和产品质量的, 但是公司真正需要关注的是产品能否解决用户问题, 是否能为客户产生价值. 这就涉及技术产品输出和用户价值输出之间的壁垒问题
    4. 收集数据的难易程度不同, 收集的数据容易数据化, 使得效能度量成为数字游戏
    5. 软件开发和实践存在滞后效应, 比如codeReview刚开始没有什么效果, 正面效果可能需要一两个月才能展现出来
- 效能度量的推荐方法, 关键点:不和绩效挂钩
    1. 目标驱动, 度量对的事情. 比如和产品价值强关联的, 应用十分可用, 线上问题十分及时处理, 紧急bug修复耗时等, 可以有以下几个度量指标
        - 净推荐值(NPS, Net Promoter Score)
        - 应用宕机时间和严重线上事故数
        - 热修复上线时间
    2. 通过主观的方式来评价, 提高效能
    3. 关注个人维度的指标
- 可以使用的方法
    1. 从全局找瓶颈, 不要以局部推断全局, 而是先获取全局信息, 找到瓶颈所在, 再优化瓶颈
    2. 关注并优化解决影响个人开发维度的问题, 比如本地启动效率, 协调机制的健全

## 研发效能实践

### 研发流程

#### 流程优化, 如何使用敏捷和精益
- 使用方法论的方式
    1. 中心目标基本不会有问题, 
    2. 原则的通用性差一些, 需要在理解的基础上选择和是自己和自己团队的
    3. 具体三时间时, 要根据自己团队的特点选择合适 的时间方式, 切不可生搬硬套
    4. 使用why-how-what的三w方法来实现, 在引入实践时, 逐步优化已有的开发流程和框架, 可以只给出原则, 然后让团队成员自己摸索并最终找到合适的方法

- 提高研发效能流程的目标, 原则和实践
    1. 目标一: 寻找用户价值, 只有对的产品才能生存下去, 这一条也是提高寻找用户价值的效率:
        1. 原则1:衡量每一个时间段成果的标准, 应该是价值假设方面的进展, 即为客户提供了多少价值, 而不是开发了多少功能 
        2. 原则2: 使用最小可行性产品来验证, 这里的产品可以是应用中的一个小功能, 只要能形成一个闭环就可以认为是一个产品. 可以提前计划好要验证哪些假设, 需要收集什么样的数据才能验证这些假设, 功能上线后就可以收集这些数据, 一旦发现收集的数据显示不能为客户提供足够的价值, 则放弃此产品
    2. 目标二: 提高用户价值的流动效率, 也就是提高研发留存各节点之间的流动效率
        1. 原则1:让功能尽快的流动.需要开发人员尽量将需求拆分, 在完成一个提交之后尽快提交
        2. 原则2:让节点之间的联动更加顺畅. 具体时间就是CICD, 其中CI至关重要
        3. 原则3:节点间的融合. 职能团队需要提供平台和工具, 让功能在节点间的流动更加的顺畅. 如果有全栈工程师的话, 要做到让全栈工程师能自己处理端到端的工作
        4. 发现整个流程中的瓶颈, 并解决它们. 具体实践有可视化和复盘
        - 第一步: 找到系统中的瓶颈
        - 第二步: 最大限度的利用瓶颈, 尽量通过提高效能的办法解决瓶颈
        - 第三步: 让企业的所有其他活动都让步于瓶颈改善工作
        - 第四步: 打破瓶颈, 如果第二, 三步无效, 就通过给瓶颈节点增加资源的方法来解决瓶颈
        - 第五步: 重返第一步, 找出新的瓶颈, 持续改善

#### 代码入库前的流程优(**持续开发**)
- 代码入库前都是由开发人员来操作的, 具体的流程有本地环境搭建, 编码, 调试, 静态检查, 自动化测试, 代码审查几个阶段. 具体工作内容可以分为开发人员实际编码和为保证代码质量进行的各种检查两个部分. 为了提高这两个部分的效率, 有两个指导的原则,一是自动化各类检查,快速反馈检查结果; 二是提高编码过程中的效率, 可以使用实时代码检查, 缩短本地编译,调试实践等方式来实现
- 持续开发: 开发人员可以不受阻碍, 不受不必要的干扰, 从而全身心的聚焦在产品开发上
- 持续开发的原则
    1. 规范化, 自动化核心步骤
    2. 快速反馈, 增量开发
- 规范化, 自动化核心步骤
    1. 提高开发环境的获取效率. 操作次此步骤的机会不多, 但是如果很复杂的化会很麻烦. 可以使用的方法有使用虚拟化机器快速生成开发环境, 可以使用Terraform工具; 也可以提供机器镜像和配置脚本来完成自动化的环境构建工作
    2. 规范化,自动化本地检查.在开发机器上进行验证, 比如语法检查, 规范检查, 单元测试, 沙盒搭建等.最好是使用统一的工具和配置, 让团队成员统一使用
    3. 建设并自动化代码入库前的检查流程. 需要在代码入库前作必要的检查工作. 比如编译检查, 代码格式检查, 重要的单元测试检查等,它起到一个门禁的作用 
- 提供快速反馈, 促进增量开发. 边开发,边验证, 提升效率
    1. 灵活使用各种Linter(语法检查之类的小工具)和测试
    2. 建设并本地调试环境. 包括增量的构建, 测试数据的产生
    3. 使用事实检测工具. 包括IDE的自动检测, 热部署, 实施编译等措施
    - 最大的好处就是可以能够大大提高开发者对当前代码的信心, 从而促进代码尽早入仓, 尽早集成
- 总结: 快速获取开发环境. 提升本地编码的非开发工作效率尽量使其自动化, 在代码入仓前作代码检查.本地测试, 本地检查, 入口前的检查都快速反馈给开发人员
- 开发人员是编码第一线的战斗人员, 他们最清楚痛点在哪, 开发人员需要自己花一定实践来优化自己的开发流程并可以与其他人分享共同进步, 管理者也需要对这些解决了问题的开发人员和方案进行适当的奖励以提升其积极性,相互影响, 才能更好的提升效率

#### 代码入库后的操作(持续集成, 持续部署, 持续交付)
- 持续集成的目的就是代码要及时的合并.定义: 在团队协作中, 一天内多次将所有开发人员的代码合并入同一条主干. 有两个需要注意的问题
    1. 需要流程尽量的频繁, 这样的话可以将小的提交快速的通过产品流水线发布到生产中, 以最快的速度试错, 从而为客户提供有价值的功能
    2. 在发布到不同环境的过程中的时候, 会发现不同的问题, 提前发现这些问题, 也有利于提升产品上线的效率
- 持续集成, 持续交付, 持续部署
    1. 从本地开发结束到代码部署到测试环境,是持续集成的过程, 包括代码检查, 自动化测试, 自动化构建等过程
    2. 从测试环境开始到代码进入到进入生产环境之前称为持续交付过程, 包括测试, 集成测试, 压力测试等其他过程
    3. 从类生产环境发布到生产环境, 当类生产环境验证完成若自动化部署到生产环境则称为持续部署
- 持续部署是发布到生产环境的最后一步, 所以持续集成/持续交付是核心的内容称为"CI/CD"
- CI/CD流水线的具体原则以及最佳实践
    - 流水线的测试要尽量完整
        1. 流程越完整, 代码和产品的质量才能有保证, 包括单元测试, 集成测试, 安全扫描, 性能测试等. 如果测试的时候发现问题的话, 开发人员还要考虑十分需要为此次失败添加新的测试用例来防止此类错误再次发生
    - 流水线的运行速度一定要快
        1. 流水线的速度一定要快, 只有速度够快, 才能支持大量的流程验证任务, 可以从以下几个角度来提升速度
            - 使用并行的方式运行各种测试来提速
            - 投入硬件资源, 使用水平扩展的方式来提速
            - 使用增量测试的方式进行精准验证. 也就是说, 只运行跟当前改动最相关的测试, 以减少测试用例的运行数量
            - 提交数量较多时, 只运行优先级较高的, 重要性比较高的测试, 和改动相关的测试. 到系统不繁忙的时候运行全量的检测案例
            - 让开发人员可以在本地机器上调用远程机器的测试用例, 使开发人员在本地开发的过程中就可以检测改动对测试用例的影响, 及早发现问题, 及早修复
    - 流水线使用的环境, 尽量和生产环境一致, 尽量减少因为环境不一致导致的发布失败,这样很不划算
        1. 软件包最好只构建一次, 保证不同的环境都使用同一个包. 如果不同的环境打包参数不一样, 可以采用环境变量的方式把这些参数传递给软件包
        2. 使用Docker镜像的方式, 把发布的产品以及环境都打包进去, 实现环境的一致性
        3. 尽量使用比较干净的环境, 防止以前的环境残留对本次部署产生影响. 可以使用新生成的环境, 也可以在每次部署完成后对环境进行清扫
    - 在CI/CD的过程中, 切不可教条主义的生般硬套, 要根据自身开发,测试,运维人员的技术水平, 自己本身的业务特点来灵活的使用. CI/CD的本质目的是希望让功能快速的通过流水线以到达发布的状态. 但是发布的间隔是可以自己把握的. 比如不需要每一个提交都持续交付, 可以是定时, 或者是每天一次. 只要找到合适自己和团队的节奏就是号的实践

#### 分支管理
- Fackbook的分支管理策略
    1. 基于主干分支开发, 开发人员从主干分支拉取功能分支进行开发
    2. 提交要尽量小, 使用rebase合并到主干分支, 对客户不可见的功能通过开关隐藏
    3. 部署时从主干分支拉取分支部署
    4. 修复bug时在主干分支上修复, 再cherry-pick到bug修复分支中
- 使用rebase合并代码的好处
    1. 确保是线性提交, 对流程自动化提供最大便利, 因为rebase合并分支是线性的, 自动化流程出现问题时, 可以通过提交线性查找, 找到bug的源头, 便于自动化流程
- 常见的分支管理策略
    1. Git-flow工作流
        - 有一个用于发布的分支master, 包含可以部署到生产环境的代码
        - 有一个用于集成代码的分支develop
        - 开发新功能, 新发布时都从develop分支拉取
        - 新功能分支, 发布分支, 热修复分支按需创建, 完成任务后分别合并到develop分支和master分支,再删除
        - 发布时, 从develop拉取release分支, 在测试环境验证, 发现问题在发布分支上修复,发布完成后将release分支合并到develop, master分支, 再大上tag, 删除分布分支
    2. Fork-merge工作流
        - 开发人员fork一个主代码仓库的代码, 所有的改动都在自己的仓库内完成, 开发完成后, 再在页面上对主代码仓库提交pull request. 这样的好处是主代码仓比较干净
    3. 灵活的功能分支组合成发布分支
        - 大量的使用工作对分支的管理进行自动化处理, 开发人员在web页面上自助产生针对功能的分支. 编码完成后, 通过web页面对分支组合, 验证, 并上线, 上线后分支再自动合入主库
        - 好处是可以基于功能开发, 每一个功能对应一个分支; 并且可以自由组合功能, 出现问题也方便添加或者删除功能
        - 不好的地方在于对工具的依赖比较高, 没有一个系统的工具基本无法实现, 而且这种方式封装了大量的地层细节, 出了问题也不太容易解决
- 选择分支的基本原则
    - 尽量减少长期分支的数量, 代码尽早合并回主仓, 方便使用CI/CD等方法保证主仓代码提交的质量

#### DevOps, SRE: 应用全栈思维打通开发和运维
- DevOps, SRE是什么?
    - 是一种重视Dev和Ops之间沟通合作的文化和惯例, 通过自动化"软件交付"和"架构变更", 使得软件的构建, 测试, 发布更加快捷, 频繁和可靠
    - SER(Site Reliability Engineer):网站可靠性功能师, 是一个职位, 是软件工程师和系统管理员的结合, 主要目标是创建可扩展且高度可靠的软件系统
- DevOps和SRE之间的关系
    - DevOps是打通开发和运维的文化和惯例, 而SRE是DevOps的具体实践之一
- DevOps, SRE是为了解决什么问题?
    - 都是为了打通Dev和Ops, 提高研发效率
- 为什么要打通Dev和Ops
    - 开发人员的职责是开发功能, 功能上线越多, 贡献越大, 所以开发人员倾向于快速上线, 多上线; 运维人员需要保证系统的稳定, 但是新功能越多, 不稳定的几率也就越大, 服务也就越不稳定, 所以运维人员不愿意多上线,快速上线, 这就是Dev和Ops之间的冲突. 而这种冲突对于公司来说是不友好的, 不能促进公司的发展
- 如何应用DevOps, SRE解决Dev和Ops之间的冲突
    - 原则1: 协调运维和开发人员的目标, 利益
        1. 让每一个工程人员对整个产品结果负责, 而不是对某一个具体环境负责
        2. 增加一个新的运维角色, 用开发的方式区做运维. 其职责是帮助开发人员推动业务快速开发, 快速上线, 具体工作包括: 优化流程, 提供自助工具
        3. 修改开发人员的职责描述为, 快速开发和上线稳定的高质量产品, 让他们也参与到一部分的运维工作中去
    - 原则2: 推动高效沟通
        1. 可以设置聊天室, 用于沟通部署进展和问题
        2. 可以引入自动化信息展示, 实时显示开发, 运维的重点信息和进度
    - 原则3: 优化从开发到部署的整个上线流程 
        1. 优化上线流程, 主要目的是解决频繁上线工作量大, 产品质量不稳定的问题
- DevOps的具体落地步骤
    1. 对团队目标达成共识, 并重新定义职责
    2. 设计CI/CD, 快速反馈, 以及团队沟通等流程
    3. 引入工具, 实现自动化
    - 首先解决人的问题, 达成共识; 再解决流程的问题, 使信息能够快速, 顺畅的在人之间流动; 使用自动化技术进一步加快流程, 减少手动操作, 提高效率, 减少错误

#### 信息流通:让团队高效协同, 让产品准确击中目标
- 信息流通指的就是各种和研发相关的信息在工具, 团队成员之间流动. 这是一个团队达成共识, 高效工作的重要因素. 其中有三点很重要, 人, 信息, 流动
- 可以从三个方面来提升信息沟通的效率
    1. 从人下手, 建立共享文化, 鼓励共享行为, 使信息共享和团队利益一致, 从而让大家愿意共享
        - 团队成员愿意共享是有效沟通的前提. 首先要让团队成员认识到信息共享的重要性, 其次要建立共享机制,鼓励共享行为, 建立共享的文化
        - 可以为每一个需求设立一个虚拟部门, 比如建立一个小的聊天群, 开发人员可以主动推动虚拟部门的沟通进程
    2. 在流程和工具方面下功夫, 整理, 归类信息, 提供工具和流程, 是信息在流水线上自动化流动
        - 标记各种信息, 并提供工具可以快速获取信息或自动化的展示这些信息
        - 信息主要分为几类
            1. 战略目标相关的信息. 这类信息要尽量公开, 并不断的和团队成员同步最新的战略目标. 这样团队成员才能更好的使自己的目标和战略目标对齐
            2. 代码相关信息, 在保证安全不泄露核心机密, 不影响核心业务的情况下, 尽量扩大代码公开的范围和受众人群
            3. 研发过程中的各种文档, 包括产品设计文档, 开发设计文档, 测试文档, 部署流程文档等
            4. 各种标识信息, 包括任务供弹, 代码commitID, 代码审查ID, 测试用例ID, BugID等, 这些在有工具的情况下, 可以极大的提高自动化流程的效率
    3. 提高沟通技巧, 掌握高效沟通的原则, 根据场景选择合适的沟通方式和工具
        - 根据沟通需要达成的人物实时性, 方便追溯性, 以及对别人的干扰程度, 选择合适的沟通工具
        - 和别人沟通前, 先整理好自己的思路, 问题是什么? 要素有哪些? 想要达成什么样的目标? 这些在沟通前都可以准备好, 这样可以明确沟通的目标, 提高沟通的效率

### 工程方法

#### 研发环境
- 软件研发需要以下几种环境
    1. 开发机器
        - 配置尽量好, 可以通过远程虚拟机器来分配开发机器, 减少资源浪费
    2. IDE
        - 尽量统一配置, 降低学习成本, 使IDE的配置自动化
    3. 开发过程中使用的各种工具, 数据和配置
    4. 本地环境, 联调环境
    5. 测试环境, 类生产环境

#### 代码审查
- 什么是代码审查?
    - 代码审查是指代码作者以外的其他人对代码进行检查, 以寻找代码的缺陷和可以提高的地方
    - 人工检查才是代码审查
- 代码审查有什么作用?
    1. 尽早发现Bug和设计中的问题. 越早发现问题, 修复的代价就越小
    2. 提高个人工程能力, 对别人的代码提建议, 可以提高自己的工程能力; 自己的代码被别人检查, 发现的问题也能促进自己改进
    3. 团队知识共享. 可以帮助其他开发者了解这些代码的设计思想, 实现方式等. 保留的文档后续也可以帮助他人理解代码, 查找问题
    4. 针对某个特定方面提高质量, 一些比较专业的领域, 比如安全, 性能, UI等, 可以邀请专业的专家进行专项审查, 还可以通过团队集体审查的方式来保证质量
    5. 统一编码风格
- 代码审查方式
    - 按审查方式分类
        1. 工具辅助的线下异步审查和面对面审查两类
    - 按审查人数分类
        1. 一对一审查, 审查者单独进行审查
        2. 团队审查, 团队成员聚在一起讨论一些代码
    - 按审查范围分类
        1. 代码增量审查, 是只针对改动部分进行审查
        2. 代码全量审查, 是对现有代码的全量. 有两个场景, 一是专项检查; 二是刚开始引入代码审查时, 对遗产代码进行一次审查
    - 按审查时机分类
        1. 代码入库前门禁检查
        2. 设计时检查, 代码设计时检查尤其重要, 此时处于设计阶段, 还没有开始编码, 发现问题不需要改动代码, 修复的成本也是最低的. 同时代码设计的评审也能促进团队技术的进步
        3. 代码入库后检查
- 如何引入代码审查
    1. 代码审查计入工作量, 管理者要明确代码审查时开发工作重要的组成部分, 并计入工作量和绩效考评
    2. 选择试点团队
    3. 选择代码审查工具, 并把机器人审查和人工审查结合起来. 机器用来自动化检查包括代码风格, 静态检查, 单元测试等可以自动化的内容; 人工检查用来检查设计, 逻辑实现等难以自动化的问题; 机器检查放在人工检查之前, 先通过机器检查发现明显的问题, 改进后再由人工来检查
- 如何持续高效的推进代码审查?
    1. 提高提交的原子性. 指一个提交包含一个不可分割的特性, 修复或者优化, 同时提交要尽可能小
    2. 提高提交说明的质量
        - 标题要简明扼要的描述这个提交
        - 详细描述中要包括这个提交的目的, 选择这个方法的原因, 实现细节的总结性描述
        - 测试情况, 做了哪些测试, 包括功能, 性能, 安全等测试方面的结果
        - 与其他工具和系统相关的信息, 比如人物ID, 业务链接等
    3. 代码作者和审查者相互尊重
    4. 基于讨论作代码审查, 代码审查的目的时讨论并发现缺陷, 潜在的bug, 而不是批判
- 引入代码审查的三个注意点
    1. 团队统一思想, 代码审查时有效工作的一部分, 应该计算到工作量里面
    2. 选择合适的试点团队
    3. 让机器人审查和人工审查结合, 使得人工审查更聚焦3. 让机器人审查和人工审查结合, 使得人工审查更聚焦3. 让机器人审查和人工审查结合, 使得人工审查更聚焦

#### 技术债
- 什么是技术债?
    - 技术债也就是在开发产品或者功能的过程中, 没有使用最佳的实现方法而引入的技术问题
- 技术债的成因
    - 主动引入: 指导某一实现会引入技术债, 但仍采用这样的实现. 最常见的情况是, 由于业务压力, 在时间和资源受限的情况下不得不牺牲质量
    - 被动引入: 即不是开发人员主动引入的技术债. 常见的原因有两种
        1. 产品不断演化, 技术不断发展, 原来的设计, 实现落伍了
        2. 开发团队的能力和水平有限, 没有采用好的开发方法, 实践
- 技术债有哪些影响?
    - 好处: 可以快速完成需求, 在快速发展市场的时候很重要
    - 坏处: 如何技术债太多, 会影响系统, 使得系统越来越难维护
- 处理技术债的基本原则是什么?
    1. 要利用技术债的好处, 必要时大胆举债
    2. 要控制技术债, 再适当的时候偿还适当部分的技术债
- 如何控制技术债?
    1. 让公司管理层意思到偿还技术债的重要性, 从而愿意投入资源
    2. 采用低成本的方式区预防
        - 加强计划, 代码审查
    3. 识别技术债并找到可能的解决方案
        - 识别复杂的相关的技术债, 解决的方法就是将一个系统拆分为多个子系统
        - 识别重用性相关的技术债, 解决的办法就是尽量复用
            1. 应用层面, 复用业务单元, 典型案例就是业务中台
            2. 架构层面, 复用基础设施后台
            3. 组件层面, 避免出现责任重叠的组建, 数据存储等
            4. 代码层面, 避免出现重复函数, 代码块
    4. 持续重构, 解决高优先级的技术债

### 如何用云计算来提高效能
- 什么是云计算?
    - 云计算就是把许多计算资源整合起来, 使用软件实现自动化管理, 通过网络快速提供给用户使用. 包括存储,
数据库, 网络, 软件, 分析服务等.
- 云计算对效能提升的影响
    - 云服务对效能有提升的主要有三个方面
        1. 服务化
        2. 自助化
        3. 弹性   
    - 服务化
        1. 服务化按照抽象程度分为三类, 包括:基础设施服务(laaS), 平台级服务(PaaS), 软件服务(SaaS). 他们被称为云计算栈, 最下层的时laaS, 最上层的时SaaS, 越上层服务越抽象, 封装的细节也就越多, 平台层处理的事物也就更多, 也就可以更加专注于业务本身
    - 自助化
        1. 云上的操作尽量减少人工参与, 主要采用自动化的办法, 通过工具或API调用来完成, 这样节约成本, 而且提高灵活性和方便性
        2. 有的云服务上还提供了CI/CD等集成功能, 这样大大降低了代码上线流水线的实现难度, 对于产品快速发布, 快速修复bug, 快速发展业务提高了很好的支持
    - 弹性和共享
        1. 业务量小的时候, 资源动态调整, 减少资源的占用, 这部分资源可以用来做其他的事情, 对资源的利用率提高
        2. 服务可以自动化的扩容, 缩容, 提高容错率, 减少资源占用
- 云计算带来的挑战
    - 为了使用云计算带来的弹性伸缩能力, 要求我们的软件架构必须是分布式的, 支持水平扩展. 分布式计算的挑战主要有亮点
        1. 自治和集中管理相结合. 需要有健康, 调用链, 能直观的看到目前系统的状态, 系统的瓶颈
        2. 错误处理, 需要控制错误的范围并做好容错机制, 可以使用的办法有
            - 信息可视化
            - 错误隔离
            - 提高系统容错性, 需要确保单个微服务的异常不会影响到其他的服务, 不造成雪崩效应
            - 自动修复能力, 比如重启
- 总结
    - 多利用云服务的服务化来隔离底层操作, 专注于业务发展, 业务发展到一定程度后, 再考虑迁移到更地层的服务或自建私有云以降低成本, 满足个性化需求
    - 利用云的自主化来加快代码上线流程, 减少系统资源获取实践, 让开发人员更加专注于业务开发, 而不被环境, 流程问题占用太多时间
    - 利用云的弹性来实现动态扩容, 动态伸缩, 实现资源共享, 降低成本, 提高容错率
    - 建立健全系统监控, 调用链监控, 实施监控业务状态, 找到瓶颈并解决它
    - 使用云时, 需要考虑云服务商提供的个性化服务是否会对后续迁移云服务产生影响

#### 各种部署及相关信息
- 蓝绿部署, 红黑部署, 灰度发布的定义和流程
    - 蓝绿发布流程
        1. 从负载均衡中删除集群A, 让集群B单独提供服务
        2. 再集群A上部署新版本
        3. 集群A升级完成后, 把负载均衡全部指向A, 并删除集群B, 由集群A单独提供服务
        4. 再集群B上部署完新版本后, 再把它添加到负载均衡中
        - 蓝绿发布适合固定机器数量的场景, 再蓝绿发布完成后, A,B两个集群都会提供服务
    - 红黑部署发布流程
        1. 先再云上申请黑色集群B, 在B上部署新版本的服务
        2. 等B升级完成后, 在一次性的将流量全部指向B
        3. 将A集群从负载均衡中删除, 并释放A集群的资源
        - 红黑发布充分利用了云计算的弹性伸缩特性
    - 灰度发布流程
        1. 在集群的一小部分机器上部署新版本, 给一部分用户使用, 以测试新版本的功能和性能; 确认没有问题后, 再对整个集群进行省级. 也叫金丝雀部署
        - 灰度发布本质属于增量发布方法
- 为什么有蓝绿, 红黑, 灰度部署
    - 减少新旧发布过程中新旧服务切换造成的服务停止实践, 蓝绿, 红黑部署都可以实现无宕机时间部署
    - 控制新版本因为质量问题带来的风险, 灰度发布就可以很好的控制风险
- 蓝绿, 红黑, 灰度部署的目标
    - 提高上线产品的效率, 也就是减少发布过程中新旧服务切换导致的停机时间
    - 提高上线产品的安全性, 也就是控制新版本引入的质量问题
- 蓝绿, 红黑, 灰度部署的阶段
    1. 部署: 将代码拷贝到服务器上运行, 但是不提供服务给客户
    2. 发布: 将部署好的服务暴露给用户的过程, 也就是开始真正上线服务用户了, 可以通过负载均衡快速实现
    3. 发布后: 服务完全上线后的阶段. 此时产品已完全上线, 主要的工作不再是预防, 而是监控和降低损失
- 如何实现蓝绿, 红黑, 灰度发布
    - 主要时流量的切换问题, 可以通过负载均衡来做到, 也可以通过流量开关来做到
#### 快速开发模式下的测试如何开展? 测试左移 and 测试右移 - 快速开发模式下测试的痛点 - 传统开发模式中, 测试有相对较长的一段时间来作测试, 可以用来测试, 提bug, 回归. 再快速开发的模式下, 由于产品发布越来越快, 留给测试的时间越来越少, 但是对于产品质量的要求确越来越高. 所以需要思考其他的测试方式来保证产品的质量. 可以通过测试左移和测试右移来解决 - 在新的开发模式下, 传统的测试模式越来越不能适应, 测试团队需要使用新的开发模式, 测试开发工具和新的测试方式会很重要 - 测试左移 - 测试左移, 测试右移就是将测试的范围从传统的测试节点中释放出来, 分别往代码提测之前和产品发布阶段延展.  - 测试左移: 让测试介入提测之前的部分. 比如开发阶段, 架构测试阶段, 让测试人员从源头了解需求, 评估需求质量,完整性等
        - 测试左移的原则
            1. 调整团队对测试的态度, 改变团队成员对测试工作的认知, 测试不仅仅时发现bug, 更重要的是预防bug;另外就是按照功能的维度管理团队, 让整个功能团队对产品负责
            2. 把测试添加到开发和产品需求步骤中
            3. 频繁测试, 快速测试, 通过自动化, 脚本检查,频繁, 快速的测试, 提供快速的反馈, 促进增量开发
- 测试右移: 再部署, 发布, 发布后的阶段进行测试
    - 部署阶段
        1. 集成测试, 使用真实的线上数据进行集成测试, 需要处理的是测试产生的测试数据. 可以通过打标或者不记录测试数据的方式来区别清理测试数据
        2. 流量镜像, 引入线上真实的数据来验证
        3. 压测, 部署到一个较小的集群, 进行压测, 客观的了解真实生产环境的抗压能力
        4. 配置方面的测试, 真实的生产环境, 验证配置很方便
    - 发布阶段
        1. 金丝雀发布先面向内部用户或特定的测试用户
        2. 监控, 发布过程中注意监控的异常信息, 比如接口失败率, 耗时, 错误信息等
    - 发布后
        1. 监控
        2. A/B测试
        3. 混沌工程

#### 研发流程, 工程方法趋势解读及展望
- 协作方式
    - 团队远程办公, 灵活工时办公, 会越来越普遍
        1. 可以克服人才地域的局限性, 上班时, 不用考虑通勤时间; 打破地域限制后, 招聘的空间也会开阔很多
        2. 减少大量通勤(上下班)时间, 进而提高研发产出
        3. 灵活工时, 就是人物驱动
        4. 远程办公尽量使用视频会议, 而不是电话会议, 视频会议的面部表情和肢体语言更容易传递信息; 二是做好信息的数字化, 可以通过工具, 自助获取的信息都不要以来面对面或者聊天系统
    - 聊天工具和其他工具的集成, 会月来越普遍
        1. 聊天工具会和其他工具比如任务工具, 部署工具, 监控系统进行集成, 通过聊天机器人就可以实时获取监控信息, 任务进度信息, 部署信息等. 还可以针对某一项任务建立聊天室讨论并存档且可以回溯讨论信息
        2. 通过给聊天机器人发送指令可以作很多方便的事情, 比如运行哪几个测试用例, 添加机器到某个集群中
- 云计算平台
    - 主要时Docker和Kubernetes带来的各种可能性, 可以在公司发展的不同阶段使用云服务商提供的不同服务, 比如初创阶段使用SaaS, 专注于业务开发, 业务发展到一定程度后, 自己定义自己个性化的需求, 可以使用Laas, h后期还可以迁移到更地层的Laas或在自建私有云
- 应用开发
    - 云原生开发和服务网格
- AI
    - 在AIOps, CD4ML(机器学习的持续交付), 语音输入比较时和研发落地
- 因为赶进度慢慢就不做代码审查了怎么办?
    1. 团队统一思想, 代码审查是有效工作的一部分, 应该计算到工作量里面.
    2. 减少团队审查, 更多的使用工具进行一对一的代码审查.  因为团队审查很那做到效率高, 所以应该只针对一些重点的提交才采用这种方式
    3. 培训团队, 统一认知, 让大家看到代码审查的长期收益
- 如何做好系统复盘
    1. 建立事故响应及根因分析系统, 用来快速响应事故, 记录事故详情, 为事故分析提供数据, 并对分析后的结果进行处理
    2. 对事故进行分类, 按照严重程度对事故分级
    3. 事故分析时, 要分析事故发生的时间, 怎么发现事故的, 如何定位, 如何解决, 如何确认解决, 后续处理方式等
    4. 事故复盘时要对事不对人, 客观的分析问题, 解决问题
    5. 对于严重等级高的事故的复盘, 需要高层管理者主持; 严重等级不高的, 团队内部消化, 但是也需要做好相应的分析, 记录, 后续处理工作

#### 高效工作
- 高效工作
    - 由于人脑不适合处理很复杂的事物, 所以对于一个系统或在任务, 可以将其分解为几个小的系统, 当处理当前系统任务时, 只关系其他系统的几个关键信息, 而不去考虑其细节. 这个拆分处理的过程就是分而治之; 而用子系统来隐藏一个领域的内部细节, 就是抽象
    - 如何实现拆分, 抽象
        1. 首先进行模块的定义, 也就是抽象, 然后对其分而治之. 比如前后端的交互, 先分为前端, 后端定义好交互API, 这就是拆分. 此时封装了前端的细节和后端的细节, 只考虑双方的数据交互, 此时就较抽象. 在后端开发时, 对后端任务进行拆分, 比如MVC分层架构, 这就是后端的分而治之, 各个层就是抽象. 就这样一层一层分解, 直到一个可以接受的原子提交
    - 抽象和分而治之的技巧就是寻找和时的设计模式, 并且大麻尽量做到原子性
- 快速迭代
    - 核心思想为快速交付代码, 快速验证, 快速验证, 在实践中逐步发展, 完善我们的代码
    1. 不要追求完美, 不要过渡设计, 而是要尽快实现功能, 通过不断迭代来完善. Done is better than prefect
    2. 在设计中, 尽量让自己的代码能够快速运行起来, 从而尽快地验证结果
    3. 为了能够快速的验证, 一个重要的实践就是设置好本地的代码检验. 比如静态扫描, 相关单元测试的方便运行以及IDE能够进行的实时检查
    4. 代码写好之后, 尽快提交到主代码仓并保证不会阻塞其他开发人员. 本地reabse主分支, 在本地执行解决冲突, 执行单元测试, 不要将问题带到主仓库中再去解决
- DRY(Don't Repeat Yourself)
    - 代码逻辑的重复: 通过重构, 将共同的部分抽象出来, 封装到模块, 类, 或者函数等机构中去
    - 流程的重复: 通过自动化的方式, 或者脚本的方式快速的执行重复的流程. 比如测试数据生成, 删除
- 具体实践
    - 抽象和分而治之
        1. 明确模块之间的依赖关系
        2. 尽快确定接口规格和可调用性
        3. 快速实现API的mock并入主仓库
        4. 寻找合适的设计模式(业界通用+公司特有)
        5. 代码原子性
        6. 对子系统代码添加合理的注释, 帮助代码阅读者对软件结构有直观的了解
    - 快速迭代
        1. 不追求完美, 不过渡设计, 尽快实现功能, 通过不断的迭代来完善功能
        2. 让自己的代码尽快的运行起来, 从而尽快的验证结果
        3. 实现一个可以运行起来的脚手架, 再不断的往里面添加东西
        4. 编写脚本或者单元测试用例来触发新的代码
        5. 设置静态扫描, 相关单元测试的本地方便运行
        6. 设置IDE在本地进行实时检查
        7. 代码写完之后, 尽快提交到主仓库
        8. 代码不方便提交带主代码仓主分支时, 频繁的将主分支rebase到本地分支上进行集成
        9. 代码在设计时进行评审, 尽早发现设计的缺陷
    - DRY
        1. 寻找重复的代码逻辑
        2. 在内部代码, 知识库中寻找重复
        3. 咨询类似功能实现者寻找重复
        4. 对重复逻辑和代码进行抽象和封装
        5. 开发新功能时, 可以先用几个提交完成重构, 再实现功能
        6. 寻找流程的重复, 使用脚本或者工具自动化
        7. 关注团队级别的重复, 并对其进行优化

#### 深度工作
- 现在的痛点
    1. 业务太忙, 需求质量不高, 被业务拖着跑, 没实践精进技术
    2. 碎片时间学习效率不高
    3. 不断被打断, 无法安心工作
- 解决办法
    1. 深入业务, 了解业务. 以始为终, 了解需求的目的, 不要急于实现, 首先查看是否有现成的方案. 其次再开发, 开发时也需要衡量多个方案的优劣.
    2. 利用好碎片化实践, 做好计划, 将需要学习的知识分解为小的点, 一点一点的学习
    3. 深度工作, 划分好工作的时间, 在工作的时间内, 尽可能隔离外部干扰
- 深度工作可以参考下列三步
    1. 以始为终, 寻找并聚焦最重要的任务
        - 在计划好的任务, 临时产生的任务, 自定义的任务中选择最重要的任务. 判断任务是否重要可以参考任务的严重性, 影响面, 紧急程度等来判断
        - 选定任务后, 聚焦任务目标, 实现它
        - 无情筛选, 少即是多
    2. 追根究底, 寻找最高效的解决方案
        - 对业务要有了解, 从业务需求的目标出发, 尝试自己的专业来对业务需求进行梳理, 不要因为业务不清楚或者不了解而造成后续的返工
    3. 安排时间和精力, 高效执行解决方案
        - 用番茄工作法来记录深度工作时间
        - 用拥抱无聊, 学习, 冥想等方法来戒除收集依赖
        - 用反向日历行事来确保休息和高效工作
- 了解业务, 能够更好的完成需求, 需求质量好, 可以减少一部分的bug和后续的零散收尾工作, 这样可以有更多的时间区学习, 工作, 是一个良性的循环

#### git
#### 命令行
#### vim
#### 工具环境集成
### 效能文化
#### 硅谷的管理和文化


#### git的提交链和多分支做法
#### 产品上线的完整流程有哪些?


