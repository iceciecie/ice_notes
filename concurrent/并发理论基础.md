#### 并发问题的源头：可见性、原子性、有序性问题
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性
- 原子性：我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性

###### 可见性问题
- 导致原因：CUP在执行程序时，会将主内存中的变量复制一份到自己的CPU缓存中，在操作变量时操作的是CPU缓存中的数据。在多核时代，当不同线程都需要操作一个共享变量时，若多个线程是在不同的CPU在执行的，则他们操作的是各自的CPU缓存，而各个CPU缓存又是相互不可见的，这就会导致数据可见性问题

###### 原子性问题
- 导致原因：操作系统进行线程切换带来原子性问题

###### 有序性问题
- 导致原因：编译优化带来有序性问题，比如双重加锁检查的单例模式

###### java如何解决可见性问题
- 使用valatile关键字，被修饰的共享变量在任何一个线程中的修改对其线程而言都是可见的

###### java如何解决有序性问题
- 虚拟机实现时会保证六项happen-before原子，这保证了语义级别的有序性
  1. 程序的顺序性原则。程序按顺序执行，前面程序比后面的程序更早执行
  2. volatile变量规则。按执行时间顺序，对一个变量的写操作早于对一个变量的读操作
  3. 传递性。如果A Happen-Before B，B Happen-Before C，则A Happen-Before C
  4. 锁的规则。对一个锁的解锁 Happen-Before 后续对这个锁的加锁
  5. 线程start()规则。主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作
  6. 线程join()规则。主线程A等待子线程B完成，子线程B操作完成后，主线程A能够看到子线程B对共享变量的操作
- valatile关键字会禁止指令重排序，在对被修饰的变量做操作时，其CPU指令的有序性是得到保证的

###### java如何解决原子性问题
- 通过互斥锁的方式保证原子性

#### 管程
###### 管程是什么？
- 管程是一种解决并发编程问题的模型，它通过管理共享变量及对共享变量的操作过程，实现“互斥”和“同步”
- 解决互斥问题：管程将共享变量和对共享变量的操作封装在一起，且确保对共享变量进操作时，只能有一个线程进入管程，这样就保证了同一时刻只有一个线程操作共享变量，以此解决了“互斥”问题
- 解决同步问题：管程的入口有一个等待队列，当多个线程同时试图进入管程内部时，只允许一个线程进入管程，其他线程就进入入口队列等待。管程中有条件变量和条件等待队列来实现变量对不同线程的影响。可以让不同的线程相互影响

###### 重点
1. 管程入口的等待队列
2. 管程内部的条件变量及条件变量等待队列
3. 不同线程通过操作条件变量并唤醒其他线程来实现线程间的唤醒通信

###### 锁
- 一个锁对应两个队列，一个是就绪队列(管程入口的等待队列)，一个是阻塞队列(条件变量等待队列)。wait()操作是将当前放入阻塞队列，而notifyall是江阻塞队列中的所有线程唤醒到就绪队列，实际上哪个线程执行由jvm操作

###### 管程模型分类
- Hasen模型，T2线程执行结束前，通知T1线程执行，通知完成后，T2就结束了。可以保证同一时刻只有一个线程在执行
- Hoare模型，T2通知完T1后，T2进入阻塞，T1执行，T1执行结束后，再唤醒T2。可以保证同一时刻只有一个线程在执行
- MEAS模型，T2通知完T1后，T2还会继续执行，T1并不马上执行，仅仅是从条件变量等待队列进入入口等待队列。可以保证同一时刻只有一个线程执行，但是坏处就是，当T1要进入管程时，又发现条件不满足而要重新进入条件变量等待队列中

###### wait()如何使用
- 在MESA中wait()需要在while循环中使用。因为在MESA模型中，线程被唤醒以后不是马上就执行的，而是从条件变量等待队列进入了入口等待队列，当准备进行管程时，可能曾经满足的条件变量现在不满足了，正是因为存在变量变化的可能性，所以需要使用循环的方式来校验变量

###### notify()如何使用
- 尽量使用notifyAll()方法
- 使用notify()的三个必要条件
  1. 所有等待线程拥有相同的等待条件
  2. 所有等待线程被唤醒后，执行的操作都是一样的
  3. 只需要唤醒一个线程

###### java中的管程
- java内置的管程synchronized中只有一个条件变量，但是不需要开发者手动加锁，解锁通过java.util.concurrent包中的并发工具类可以实现多个条件变量，但是需要自己实现加锁，解锁操作
